// Generated by CoffeeScript 2.2.1
(function() {
  /*
  data structure spec
    pos: [pos_x, pos_y]
    coord: [coord_x, coord_y]

  all events:

  raw input
    mousedown, mouseup, mousemove {pos}
  input operation
    pick, drop, hover {coord}
  game operation
    op_movepiece {piece, coord_from, coord_to}
  battle
    battle_attack {piece_atker, piece_atkee, coord_from, coord_to, damage}
    battle_assist {piece_aster, piece_astee, coord_from, coord_to, assistance}
    battle_heal {piece_healer, piece_healee, coord_from, coord_to, recuperation}
    battle_move {piece, coord_from, coord_to}
  game
    move_round_begin { board }, move_round { board }, move_round_end { board }
    assist_round_begin { board }, assist_round { board }, assist_round_end { board }
    recover_round_begin { board }, recover_round { board }, recover_round_end { board }
    attack_round_begin { board }, attack_round { board }, attack_round_end { board }
    end_of_rounds { board }
    ai_think_round { board }
    gametick {}
    render {}
    game_end { result: draw/win, player }
  piece state
    piece_die {piece, coord}
    piece_hurt {piece, coord}
  network
    network_out_gamestate {gamestate}
    network_out_operation {operation}
    network_in_gamestate {gamestate}
    network_in_operation {operation}
  */
  var dispatch_event, dispatch_one_event_from_queue, dispatch_queue, dispatching, event_queue, halt, halted, handlers, hook, init, resume, trigger, trigger_now, unhook;

  handlers = {};

  dispatching = false;

  event_queue = [];

  halted = false;

  trigger = function(evt_name, evt) {
    event_queue.push([evt_name, evt]);
    if (!dispatching) { // the event being dispatched may trigger other events
      dispatching = true;
      dispatch_queue();
      return dispatching = false;
    }
  };

  trigger_now = function(evt_name, evt) {
    event_queue.push([evt_name, evt]);
    return dispatch_queue();
  };

  dispatch_queue = function() {
    var results;
    if (!halted) {
      results = [];
      while (event_queue.length > 0) {
        results.push(dispatch_one_event_from_queue());
      }
      return results;
    }
  };

  dispatch_one_event_from_queue = function() {
    var evt, evt_name;
    [evt_name, evt] = event_queue.shift();
    return dispatch_event(evt_name, evt);
  };

  dispatch_event = function(evt_name, evt) {
    var hdl, hdls, i, len, ref, results;
    hdls = handlers[evt_name];
    if (hdls != null) {
      ref = calc.copy_array(hdls);
      // some handlers may be unhooked during the invocation,
      // so make a copy of all handlers first before invoking them.
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        hdl = ref[i];
        results.push(hdl(evt));
      }
      return results;
    }
  };

  hook = function(evt_name, hdl) {
    if (handlers[evt_name] == null) {
      handlers[evt_name] = [];
    }
    return handlers[evt_name].push(hdl);
  };

  unhook = function(evt_name, hdl) {
    var hdls;
    hdls = handlers[evt_name];
    if (hdls != null) {
      return calc.remove_item_from_array(hdl, hdls);
    }
  };

  init = function() {
    handlers = {};
    dispatching = false;
    return event_queue = [];
  };

  halt = function() {
    return halted = true;
  };

  resume = function() {
    return halted = false;
  };

  window.ev = {init, trigger, trigger_now, hook, unhook, halt, resume};

}).call(this);

//# sourceMappingURL=event.js.map
