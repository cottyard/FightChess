// Generated by CoffeeScript 2.2.1
(function() {
  var background, board, determine_shield_transparency, hp_indicator, mark_grid, move_cd_indicator, paint_grid, piece_at_pos, piece_drawing_types, piece_super_pawn_decorator, piece_with_indicators, shield_indicator;

  piece_drawing_types = {
    black: {
      pawn: '\u265F',
      super_pawn: '\u265F',
      knight: '\u265E',
      bishop: '\u265D',
      rook: '\u265C',
      queen: '\u265B',
      king: '\u265A'
    },
    white: {
      pawn: '\u2659',
      super_pawn: '\u2659',
      knight: '\u2658',
      bishop: '\u2657',
      rook: '\u2656',
      queen: '\u2655',
      king: '\u2654'
    }
  };

  piece_super_pawn_decorator = '\u2B51';

  // indicators
  shield_indicator = function(ctx, coord, current, total) {
    var transparency;
    transparency = determine_shield_transparency(current);
    return paint_grid(ctx, coord, `rgba(0, 0, 255, ${transparency})`);
  };

  // half = settings.half_grid_size
  // length = settings.grid_size - 7
  // percentage = current / total
  // cut_length = (1 - percentage) * length
  // transparency = determine_shield_transparency total
  // x = pos_x - half + cut_length
  // y = pos_y - half
  // w = length - cut_length
  // h = 7
  // shape.set_style ctx, shape.style_white
  // shape.rectangle ctx, x, y, w, h, yes
  // shape.set_style ctx, "rgba(0, 0, 255, #{transparency})"
  // shape.rectangle ctx, x, y, w, h, yes
  hp_indicator = function(ctx, [pos_x, pos_y], current, total) {
    var color_offset, current_, cut_length, green_offset, h, half, length, percentage, red_offset, total_, w, x, y;
    half = settings.half_grid_size;
    // for hp < 10%, give the red indicator.
    // for hp > 10%, give a gradient color from green to red.
    total_ = 0.9 * total;
    current_ = current;
    current_ -= 0.1 * total_;
    if (current_ < 0) {
      current_ = 0;
    }
    color_offset = Math.floor((total_ - current_) / total_ * 255 * 2);
    red_offset = color_offset > 255 ? 255 : color_offset;
    green_offset = color_offset - red_offset;
    // shape.rectangle ctx, pos_x + half - 7, pos_y - half, 7, 7, yes
    half = settings.half_grid_size;
    length = settings.grid_size;
    percentage = current / total;
    cut_length = (1 - percentage) * length;
    x = pos_x - half + cut_length;
    y = pos_y - half;
    w = length - cut_length;
    h = settings.top_indicator_height;
    // shape.set_style ctx, shape.style_white
    // shape.rectangle ctx, x, y, w, h, yes
    shape.set_style(ctx, `rgba(${red_offset}, ${255 - green_offset}, 0, 0.9)`);
    return shape.rectangle(ctx, x, y, w, h, true);
  };

  move_cd_indicator = function(ctx, [pos_x, pos_y], current, total) {
    var half, percentage;
    if (current === 0) {
      return;
    }
    percentage = (total - current) / total;
    half = settings.half_grid_size;
    shape.save_style(ctx);
    shape.set_style(ctx, "rgba(0, 255, 255, 0.7)");
    shape.rectangle(ctx, pos_x - half, pos_y + half - 3, settings.grid_size * percentage, 4, true);
    return shape.restore_style(ctx);
  };

  determine_shield_transparency = function(val) {
    if (val >= 10) {
      return 0.5;
    } else {
      return val / 20;
    }
  };

  // api
  background = function(ctx, size) {
    var grid_size, i, j, ref, ref1, ref2, ref3, x, y;
    ctx.save();
    grid_size = settings.grid_size;
    shape.set_style(ctx, shape.style_grey);
    for (x = i = 0, ref = size, ref1 = grid_size; ref1 !== 0 && (0 <= ref ? 0 <= i && i < ref : 0 >= i && i > ref); x = i += ref1) {
      for (y = j = 0, ref2 = size, ref3 = grid_size; ref3 !== 0 && (0 <= ref2 ? 0 <= j && j < ref2 : 0 >= j && j > ref2); y = j += ref3) {
        if ((x + y) / grid_size % 2 !== 0) {
          shape.rectangle(ctx, x, y, grid_size, grid_size, true);
        }
      }
    }
    return ctx.restore();
  };

  piece_with_indicators = function(ctx, piece, coord) {
    var pos_x, pos_y;
    [pos_x, pos_y] = calc.coord_to_pos(coord);
    piece_at_pos(ctx, piece, [pos_x, pos_y]);
    shape.save_style(ctx);
    hp_indicator(ctx, [pos_x, pos_y], piece.hp, piece.hp_total);
    shield_indicator(ctx, coord, piece.shield, piece.shield_total);
    move_cd_indicator(ctx, [pos_x, pos_y], piece.move_cd_ticks, piece.move_cd);
    return shape.restore_style(ctx);
  };

  piece_at_pos = function(ctx, piece, [pos_x, pos_y]) {
    var color, half, style, type;
    color = piece.color;
    type = piece.type;
    half = settings.half_grid_size;
    style = piece.can_move() ? null : shape.style_light;
    shape.text(ctx, piece_drawing_types[color][type], pos_x - half + 5, pos_y - half + 40, style);
    if (piece.type === 'super_pawn') {
      return shape.text(ctx, piece_super_pawn_decorator, pos_x + 3, pos_y - half + 28);
    }
  };

  board = function(ctx) {
    var coord, p, ref, results, z;
    ref = battleground.instance.all_pieces();
    results = [];
    for (z of ref) {
      [coord, p] = z;
      results.push(piece_with_indicators(ctx, p, coord));
    }
    return results;
  };

  paint_grid = function(ctx, coord, style) {
    var x, y;
    shape.save_style(ctx);
    shape.set_style(ctx, style);
    [x, y] = calc.coord_to_pos(coord);
    shape.rectangle(ctx, x - settings.half_grid_size, y - settings.half_grid_size + settings.top_indicator_height, settings.grid_size, settings.grid_size - settings.top_indicator_height, true);
    return shape.restore_style(ctx);
  };

  mark_grid = function(ctx, coord, style) {
    var grid_size, padding, x, y;
    padding = 2;
    grid_size = settings.grid_size;
    [x, y] = coord;
    [x, y] = [(x - 1) * grid_size + padding, (y - 1) * grid_size + padding];
    ctx.save();
    ctx.lineWidth = 1 + (padding - 1) * 2;
    if (style != null) {
      shape.set_style(ctx, style);
    }
    shape.rectangle(ctx, x, y, grid_size - 2 * padding, grid_size - 2 * padding);
    return ctx.restore();
  };

  window.paint = {background, piece_at_pos, board, paint_grid, mark_grid};

}).call(this);

//# sourceMappingURL=paint.js.map
