// Generated by CoffeeScript 1.8.0
(function() {
  var Board, get_state, init, on_render, set_state, write_buffer_to_buffer;

  Board = (function() {
    var piece_arrangement;

    piece_arrangement = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

    function Board() {
      var i, j;
      this.board = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; _i <= 8; i = ++_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (j = _j = 1; _j <= 8; j = ++_j) {
              _results1.push(null);
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    Board.prototype.set_out_board = function() {
      var x, _i, _j, _results;
      for (x = _i = 1; _i <= 8; x = ++_i) {
        this.place_piece(new piece.Piece('white', 'pawn', [x, 7]));
        this.place_piece(new piece.Piece('white', piece_arrangement[x - 1], [x, 8]));
      }
      _results = [];
      for (x = _j = 1; _j <= 8; x = ++_j) {
        this.place_piece(new piece.Piece('black', 'pawn', [x, 2]));
        _results.push(this.place_piece(new piece.Piece('black', piece_arrangement[x - 1], [x, 1])));
      }
      return _results;
    };

    Board.prototype.clean_up_board = function() {
      var i, j, _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 8; i = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (j = _j = 1; _j <= 8; j = ++_j) {
            if (this.is_occupied([i, j])) {
              this.get_piece([i, j]).unhook_actions();
              _results1.push(this.lift_piece([i, j]));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.is_occupied = function(_arg) {
      var coord_x, coord_y;
      coord_x = _arg[0], coord_y = _arg[1];
      return this.board[coord_x - 1][coord_y - 1] != null;
    };

    Board.prototype.get_piece = function(_arg) {
      var coord_x, coord_y;
      coord_x = _arg[0], coord_y = _arg[1];
      return this.board[coord_x - 1][coord_y - 1];
    };

    Board.prototype.lift_piece = function(_arg) {
      var coord_x, coord_y;
      coord_x = _arg[0], coord_y = _arg[1];
      return this.board[coord_x - 1][coord_y - 1] = null;
    };

    Board.prototype.place_piece = function(piece) {
      var coord_x, coord_y, _ref;
      _ref = piece.coordinate, coord_x = _ref[0], coord_y = _ref[1];
      return this.board[coord_x - 1][coord_y - 1] = piece;
    };

    return Board;

  })();

  init = function() {
    board.instance = new Board();
    board.instance.set_out_board();
    return ev.hook('render', on_render);
  };

  on_render = function(evt) {
    return paint.board(ui.ctx["static"]);
  };

  write_buffer_to_buffer = function(buffer_1, buffer_2, from_1, from_2, size) {
    var i, view_1, view_2, _i, _results;
    view_1 = new Uint8Array(buffer_1);
    view_2 = new Uint8Array(buffer_2);
    _results = [];
    for (i = _i = 1; 1 <= size ? _i <= size : _i >= size; i = 1 <= size ? ++_i : --_i) {
      _results.push(view_2[from_2++] = view_1[from_1++]);
    }
    return _results;
  };

  get_state = function() {
    var buffer, p, pb, pieces, pointer, serialized_pieces, _i, _j, _k, _len, _len1, _len2, _ref;
    serialized_pieces = [];
    _ref = board.instance.board;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pieces = _ref[_i];
      for (_j = 0, _len1 = pieces.length; _j < _len1; _j++) {
        p = pieces[_j];
        if (p != null) {
          serialized_pieces.push(piece.serialize_piece(p));
        }
      }
    }
    buffer = new ArrayBuffer(serialized_pieces.length * piece.serialization_btyes);
    pointer = 0;
    for (_k = 0, _len2 = serialized_pieces.length; _k < _len2; _k++) {
      pb = serialized_pieces[_k];
      write_buffer_to_buffer(pb, buffer, 0, pointer, piece.serialization_btyes);
      pointer += piece.serialization_btyes;
    }
    return buffer;
  };

  set_state = function(buffer) {
    var i, p, pb, piece_count, pointer, _i, _results;
    board.instance.clean_up_board();
    piece_count = buffer.byteLength / piece.serialization_btyes;
    pointer = 0;
    _results = [];
    for (i = _i = 0; 0 <= piece_count ? _i < piece_count : _i > piece_count; i = 0 <= piece_count ? ++_i : --_i) {
      pb = new ArrayBuffer(piece.serialization_btyes);
      write_buffer_to_buffer(buffer, pb, i * piece.serialization_btyes, 0, piece.serialization_btyes);
      p = piece.deserialize_piece(pb);
      _results.push(board.instance.place_piece(p));
    }
    return _results;
  };

  window.board = {
    init: init,
    instance: null,
    get_state: get_state,
    set_state: set_state
  };

}).call(this);
