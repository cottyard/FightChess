// Generated by CoffeeScript 2.2.1
(function() {
  var evaluate_board, evaluate_move, generate_all_moves, pawn_pos_value, super_pawn_pos_value, think_of_one_operation, type_value;

  generate_all_moves = function(board, color) {
    var all_moves, c, coord, i, len, moves, p, ref, ref1, x;
    all_moves = [];
    ref = board.all_pieces();
    for (x of ref) {
      [coord, p] = x;
      if (p.color !== color) {
        continue;
      }
      if (!p.can_move()) {
        continue;
      }
      moves = board.get_valid_moves(coord);
      ref1 = moves.regular;
      for (i = 0, len = ref1.length; i < len; i++) {
        c = ref1[i];
        all_moves.push({
          piece: p,
          coord_to: c,
          coord_from: coord
        });
      }
    }
    return all_moves;
  };

  type_value = {
    'pawn': 10,
    'super_pawn': 20,
    'knight': 30,
    'bishop': 30,
    'rook': 30,
    'queen': 30,
    'king': 0
  };

  pawn_pos_value = {
    1: 0,
    2: 0,
    3: 0,
    4: 2,
    5: 3,
    6: 4,
    7: 5,
    8: 0
  };

  super_pawn_pos_value = {
    1: 0,
    2: 6,
    3: 5,
    4: 4,
    5: 3,
    6: 2,
    7: 1,
    8: 0
  };

  evaluate_board = function(board, color) {};

  // e = 0
  // for [[col, row], p] from b.all_pieces()
  //   ours = p.color is color
  //   if ours
  //     e += type_value[p.type]
  //     if p.type is 'pawn'
  //       e += pawn_pos_value[?]
  evaluate_move = function(board, color, move) {
    var attacks, b;
    b = board.clone();
    b.move_to(move.coord_from, move.coord_to);
    if (!p.can_move()) {
      continue;
    }
    b.get_valid_moves(coord);
    attacks = current_piece.valid_moves(b).offensive.length;
    if (current_piece.color === move.piece.color) {
      return evaluation += attacks;
    } else {
      return evaluation -= attacks;
    }
  };

  think_of_one_operation = function(board, color) {
    var all_moves, evaluation, m;
    all_moves = generate_all_moves(board, color);
    evaluation = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = all_moves.length; i < len; i++) {
        m = all_moves[i];
        results.push([evaluate_move(board, m), m]);
      }
      return results;
    })();
    evaluation.sort(function(e1, e2) {
      return e2[0] - e1[0];
    });
    //console.log (String(m[1].coord_to[0])+String(m[1].coord_to[1]) for m in evaluation)
    //console.log (m[0] for m in evaluation)
    //console.log evaluation
    if (evaluation[0] != null) {
      return evaluation[0][1];
    } else {
      return 'abort';
    }
  };

  window.ai.dolphin = {think_of_one_operation};

}).call(this);

//# sourceMappingURL=dolphin.js.map
