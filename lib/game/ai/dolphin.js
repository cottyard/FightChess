// Generated by CoffeeScript 2.2.1
(function() {
  var evaluate_move, generate_all_moves, think_of_one_operation;

  generate_all_moves = function(board, color) {
    var all_moves, coord, current_piece, i, j, k, l, len, n, ref;
    all_moves = [];
    for (i = k = 1; k <= 8; i = ++k) {
      for (j = l = 1; l <= 8; j = ++l) {
        if (!board.is_occupied([j, i])) {
          continue;
        }
        current_piece = board.get_piece([j, i]);
        if (current_piece.color !== color) {
          continue;
        }
        if (!current_piece.can_move()) {
          continue;
        }
        ref = current_piece.valid_moves().regular;
        for (n = 0, len = ref.length; n < len; n++) {
          coord = ref[n];
          all_moves.push({
            piece: current_piece,
            coord_to: coord
          });
        }
      }
    }
    return all_moves;
  };

  evaluate_move = function(board, move) {
    var attacks, current_piece, evaluation, i, j, k, l, new_board, p;
    new_board = calc.clone(board);
    p = new_board.get_piece(move.piece.coordinate);
    new_board.lift_piece(move.piece.coordinate);
    p.coordinate = move.coord_to;
    new_board.place_piece(p);
    evaluation = 0;
    for (i = k = 1; k <= 8; i = ++k) {
      for (j = l = 1; l <= 8; j = ++l) {
        if (!new_board.is_occupied([j, i])) {
          continue;
        }
        current_piece = new_board.get_piece([j, i]);
        attacks = current_piece.valid_moves(new_board).offensive.length;
        if (current_piece.color === move.piece.color) {
          evaluation += attacks;
        } else {
          evaluation -= attacks;
        }
      }
    }
    return evaluation;
  };

  think_of_one_operation = function(board, color) {
    var all_moves, evaluation, m;
    all_moves = generate_all_moves(board, color);
    evaluation = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = all_moves.length; k < len; k++) {
        m = all_moves[k];
        results.push([evaluate_move(board, m), m]);
      }
      return results;
    })();
    evaluation.sort(function(e1, e2) {
      return e2[0] - e1[0];
    });
    //console.log (String(m[1].coord_to[0])+String(m[1].coord_to[1]) for m in evaluation)
    //console.log (m[0] for m in evaluation)
    //console.log evaluation
    if (evaluation[0] != null) {
      return evaluation[0][1];
    } else {
      return 'abort';
    }
  };

  window.ai.dolphin = {think_of_one_operation};

}).call(this);

//# sourceMappingURL=dolphin.js.map
