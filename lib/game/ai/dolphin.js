// Generated by CoffeeScript 2.2.1
(function() {
  var evaluate_board, evaluate_move, generate_all_moves, pawn_pos_value, super_pawn_pos_value, think_of_one_operation, type_value;

  generate_all_moves = function(board, color) {
    var all_moves, c, coord, i, len, moves, p, ref, ref1, x;
    all_moves = [];
    ref = board.all_pieces();
    for (x of ref) {
      [coord, p] = x;
      if (p.color !== color) {
        continue;
      }
      if (!p.can_move()) {
        continue;
      }
      moves = board.get_valid_moves(coord);
      ref1 = moves.regular;
      for (i = 0, len = ref1.length; i < len; i++) {
        c = ref1[i];
        all_moves.push({
          piece: p,
          coord_to: c,
          coord_from: coord
        });
      }
    }
    return all_moves;
  };

  type_value = {
    'pawn': 10,
    'super_pawn': 20,
    'knight': 30,
    'bishop': 30,
    'rook': 30,
    'queen': 30,
    'king': 0
  };

  pawn_pos_value = {
    white: [null, 0, 5, 4, 3, 2, 0, 0, 0],
    black: [null, 0, 0, 2, 3, 4, 5, 0, 0]
  };

  super_pawn_pos_value = {
    white: [null, 0, 1, 2, 3, 4, 5, 6, 0],
    black: [null, 0, 6, 5, 4, 3, 2, 1, 0]
  };

  evaluate_board = function(board, color) {
    var coeff, col, e, moves, ours, p, ref, row, x;
    e = 0;
    ref = board.all_pieces();
    for (x of ref) {
      [[col, row], p] = x;
      ours = p.color === color;
      if (ours) {
        e += type_value[p.type];
        if (p.type === 'pawn') {
          e += pawn_pos_value[color][row];
        }
        if (p.type === 'super_pawn') {
          e += super_pawn_pos_value[color][row];
        }
      }
      moves = board.get_valid_moves([col, row]);
      coeff = ours != null ? ours : {
        1: -1
      };
      e += moves.offensive.length * coeff;
      e -= moves.defensive.length * coeff * 0.5;
    }
    return e;
  };

  evaluate_move = function(board, color, move) {
    var b;
    b = board.clone();
    b.move_to(move.coord_from, move.coord_to);
    return evaluate_board(b, color);
  };

  think_of_one_operation = function(board, color) {
    var all_moves, current, evaluations, m, max_e;
    current = evaluate_board(board);
    all_moves = generate_all_moves(board, color);
    //console.log (String(m[1].coord_to[0])+String(m[1].coord_to[1]) for m in evaluation)
    //console.log (m[0] for m in evaluation)
    evaluations = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = all_moves.length; i < len; i++) {
        m = all_moves[i];
        results.push([evaluate_move(board, color, m), m]);
      }
      return results;
    })();
    evaluations.sort(function(e1, e2) {
      return e2[0] - e1[0];
    });
    if (evaluations[0] == null) {
      return 'abort';
    }
    [max_e, m] = evaluations[0];
    if (max_e > current) {
      return m;
    } else {
      return 'abort';
    }
  };

  window.ai.dolphin = {think_of_one_operation};

}).call(this);

//# sourceMappingURL=dolphin.js.map
