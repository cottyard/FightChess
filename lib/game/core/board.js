// Generated by CoffeeScript 2.2.1
(function() {
  var Board, deserialize, serialize, transform_column, try_promoting, try_transforming;

  Board = (function() {
    var king_spawn_coord, players, spawn_row;

    class Board {
      constructor(is_battleground) {
        var i, j;
        this.on_assist_round_begin = this.on_assist_round_begin.bind(this);
        this.on_assist_round_end = this.on_assist_round_end.bind(this);
        this.on_attack_round_begin = this.on_attack_round_begin.bind(this);
        this.on_attack_round_end = this.on_attack_round_end.bind(this);
        this.on_recover_round = this.on_recover_round.bind(this);
        this.on_move_round_end = this.on_move_round_end.bind(this);
        this.is_battleground = is_battleground;
        this.board = (function() {
          var k, results;
          results = [];
          for (i = k = 1; k <= 8; i = ++k) {
            results.push((function() {
              var l, results1;
              results1 = [];
              for (j = l = 1; l <= 8; j = ++l) {
                results1.push(null);
              }
              return results1;
            })());
          }
          return results;
        })();
        this.spawn_cd = {
          white: 0,
          black: 0
        };
        if (this.is_battleground == null) {
          this.is_battleground = false;
        }
        if (this.is_battleground) {
          this.hook();
        }
      }

      set_out_board() {
        var k, len, p, results;
        results = [];
        for (k = 0, len = players.length; k < len; k++) {
          p = players[k];
          this.place_piece(new piece.Piece(p, 'king'), king_spawn_coord[p]);
          this.spawn(p);
          this.spawn(p);
          results.push(this.activate_spawn_cd(p));
        }
        return results;
      }

      count_piece(type, color) {
        var coord, count, p, ref, x;
        count = 0;
        ref = this.all_pieces();
        for (x of ref) {
          [coord, p] = x;
          if (p.type === type && p.color === color) {
            count++;
          }
        }
        return count;
      }

      count_pieces() {
        var coord, count, k, len, p, ref, x;
        count = {};
        for (k = 0, len = players.length; k < len; k++) {
          p = players[k];
          count[p] = 0;
        }
        ref = this.all_pieces();
        for (x of ref) {
          [coord, p] = x;
          count[p.color]++;
        }
        return count;
      }

      activate_spawn_cd(color) {
        return this.spawn_cd[color] = rule.spawn.spawn_cd(this.count_pieces()[color]);
      }

      reduce_spawn_cd() {
        var k, len, p, results;
        results = [];
        for (k = 0, len = players.length; k < len; k++) {
          p = players[k];
          if (this.spawn_cd[p] > 0) {
            results.push(this.spawn_cd[p]--);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }

      * all_pieces() {
        var i, j, k, results;
        results = [];
        for (i = k = 1; k <= 8; i = ++k) {
          results.push((yield* (function*() {
            var l, results1;
            results1 = [];
            for (j = l = 1; l <= 8; j = ++l) {
              if (this.is_occupied([i, j])) {
                results1.push((yield [[i, j], this.get_piece([i, j])]));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this)));
        }
        return results;
      }

      clean_up_board() {
        var i, j, piece, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [[i, j], piece] = x;
          results.push(this.lift_piece([i, j]));
        }
        return results;
      }

      get_piece([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1];
      }

      lift_piece([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] = null;
      }

      place_piece(piece, [coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] = piece;
      }

      is_occupied([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] != null;
      }

      spawn(color) {
        var col, k, row, spawn_cols;
        spawn_cols = [];
        row = spawn_row[color];
        for (col = k = 1; k <= 8; col = ++k) {
          if (!this.is_occupied([col, row])) {
            spawn_cols.push(col);
          }
        }
        if (!(spawn_cols.length > 0)) {
          return false;
        }
        this.place_piece(new piece.Piece(color, 'pawn'), [spawn_cols[calc.randint([0, spawn_cols.length - 1])], row]);
        return true;
      }

      is_battleground() {
        return this.is_battleground;
      }

      clone() {
        var brd, coord, piece, ref, x;
        brd = new Board();
        ref = this.all_pieces();
        for (x of ref) {
          [coord, piece] = x;
          brd.place_piece(piece.clone(), coord);
        }
        return brd;
      }

      hook() {
        ev.hook('assist_round_begin', this.on_assist_round_begin);
        ev.hook('assist_round_end', this.on_assist_round_end);
        ev.hook('attack_round_begin', this.on_attack_round_begin);
        ev.hook('attack_round_end', this.on_attack_round_end);
        ev.hook('recover_round', this.on_recover_round);
        return ev.hook('move_round_end', this.on_move_round_end);
      }

      unhook() {
        ev.unhook('assist_round_begin', this.on_assist_round_begin);
        ev.unhook('assist_round_end', this.on_assist_round_end);
        ev.unhook('attack_round_begin', this.on_attack_round_begin);
        ev.unhook('attack_round_end', this.on_attack_round_end);
        ev.unhook('recover_round', this.on_recover_round);
        return ev.unhook('move_round_end', this.on_move_round_end);
      }

      on_assist_round_begin() {
        var astee, coord, def_coord, moves, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          p.reset_assisted_abilities();
          moves = rule.move.valid_moves(p.type, p.color, coord, this);
          results.push((function() {
            var k, len, ref1, results1;
            ref1 = moves.defensive;
            results1 = [];
            for (k = 0, len = ref1.length; k < len; k++) {
              def_coord = ref1[k];
              astee = this.get_piece(def_coord);
              results1.push(ev.trigger('battle_assist', {
                aster: p,
                astee: astee,
                coord_from: coord,
                coord_to: def_coord,
                assistance: p.assistance,
                heal: p.heal
              }));
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      on_assist_round_end() {
        var coord, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          results.push(p.adjust_shield());
        }
        return results;
      }

      on_attack_round_begin() {
        var atk_coord, coord, k, len, moves, p, ref, ref1, results, target, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          if (p.attack_cd_ticks > 0) {
            continue;
          }
          moves = rule.move.valid_moves(p.type, p.color, coord, this);
          if (moves.offensive.length === 0) {
            continue;
          }
          ref1 = moves.offensive;
          for (k = 0, len = ref1.length; k < len; k++) {
            atk_coord = ref1[k];
            target = this.get_piece(atk_coord);
            ev.trigger('battle_attack', {
              atker: p,
              atkee: target,
              coord_from: coord,
              coord_to: atk_coord,
              damage: p.attack
            });
          }
          results.push(p.activate_attack_cd());
        }
        return results;
      }

      on_attack_round_end() {
        var coord, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          if (p.is_dead()) {
            this.lift_piece(coord);
            results.push(ev.trigger('piece_die', {
              piece: p,
              coord: coord
            }));
          } else {
            results.push(p.reduce_attack_cd());
          }
        }
        return results;
      }

      on_recover_round() {
        var coord, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          p.recover_shield();
          p.recover_hp();
          results.push(p.reduce_move_cd());
        }
        return results;
      }

      on_move_round_end() {
        var count, k, len, p, results;
        this.reduce_spawn_cd();
        results = [];
        for (k = 0, len = players.length; k < len; k++) {
          p = players[k];
          if (this.spawn_cd[p] === 0) {
            count = this.count_pieces()[p];
            if (count >= 16) {
              continue;
            }
            if (this.spawn(p)) {
              results.push(this.activate_spawn_cd(p));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }

      get_valid_regular_moves(coord) {
        var p;
        if (!this.is_occupied(coord)) {
          return rule.move.empty_moves;
        }
        p = this.get_piece(coord);
        if (!p.can_move()) {
          return rule.move.empty_moves;
        }
        return (rule.move.valid_moves(p.type, p.color, coord, this)).regular;
      }

      get_moves(coord) {
        var p;
        if (!this.is_occupied(coord)) {
          return rule.move.empty_moves;
        }
        p = this.get_piece(coord);
        return rule.move.valid_moves(p.type, p.color, coord, this);
      }

      move_to(from_coord, to_coord) {
        var p;
        if (!this.is_occupied(from_coord)) {
          return;
        }
        if (this.is_occupied(to_coord)) {
          return;
        }
        p = this.get_piece(from_coord);
        this.place_piece(p, to_coord);
        this.lift_piece(from_coord);
        p.activate_move_cd();
        try_promoting(p, to_coord);
        return try_transforming(p, to_coord);
      }

    };

    players = ['white', 'black'];

    spawn_row = {
      white: 7,
      black: 2
    };

    king_spawn_coord = {
      white: [5, 8],
      black: [5, 1]
    };

    return Board;

  }).call(this);

  try_promoting = function(piece, coord) {
    if (piece.type !== 'pawn') {
      return;
    }
    if ((piece.color === 'white' && coord[1] === 1) || (piece.color === 'black' && coord[1] === 8)) {
      piece.change_type('super_pawn');
      return piece.activate_move_cd();
    }
  };

  transform_column = ['rook', 'knight', 'bishop', 'queen', 'queen', 'bishop', 'knight', 'rook'];

  try_transforming = function(piece, coord) {
    if (piece.type !== 'super_pawn') {
      return;
    }
    if ((piece.color === 'white' && coord[1] === 8) || (piece.color === 'black' && coord[1] === 1)) {
      piece.change_type(transform_column[coord[0] - 1]);
      return piece.activate_move_cd();
    }
  };

  serialize = function(board) {
    var buffer, coord, k, len, p, ref, serialized_pieces, sp, x;
    serialized_pieces = [];
    ref = board.all_pieces();
    for (x of ref) {
      [coord, p] = x;
      serialized_pieces.push(piece.serialize(p, coord));
    }
    buffer = new ArrayBuffer(serialized_pieces.length * piece.serialization_size + 4);
    p = 0;
    for (k = 0, len = serialized_pieces.length; k < len; k++) {
      sp = serialized_pieces[k];
      calc.write_buf_to_buf(sp, buffer, 0, p, piece.serialization_size);
      p += piece.serialization_size;
    }
    calc.write_to_buffer(buffer, p, board.spawn_cd['white']);
    calc.write_to_buffer(buffer, p + 2, board.spawn_cd['black']);
    return buffer;
  };

  deserialize = function(buffer, board) {
    var coord, i, k, p, piece_count, ref, sp;
    board.clean_up_board();
    piece_count = (buffer.byteLength - 4) / piece.serialization_size;
    for (i = k = 0, ref = piece_count; undefined !== 0 && (0 <= ref ? 0 <= k && k < ref : 0 >= k && k > ref); i = 0 <= ref ? ++k : --k) {
      sp = new ArrayBuffer(piece.serialization_size);
      calc.write_buf_to_buf(buffer, sp, i * piece.serialization_size, 0, piece.serialization_size);
      [p, coord] = piece.deserialize(sp);
      board.place_piece(p, coord);
    }
    board.spawn_cd['white'] = calc.read_from_buffer(buffer, buffer.byteLength - 4);
    return board.spawn_cd['black'] = calc.read_from_buffer(buffer, buffer.byteLength - 2);
  };

  window.board = {Board, serialize, deserialize};

}).call(this);

//# sourceMappingURL=board.js.map
