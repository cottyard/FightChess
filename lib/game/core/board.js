// Generated by CoffeeScript 2.2.1
(function() {
  var Board, transform_column, try_promoting, try_transforming;

  Board = (function() {
    var king_spawn_coord, spawn_row;

    class Board {
      constructor(is_battleground) {
        var i, j;
        this.on_assist_round_begin = this.on_assist_round_begin.bind(this);
        this.on_assist_round_end = this.on_assist_round_end.bind(this);
        this.on_attack_round_begin = this.on_attack_round_begin.bind(this);
        this.on_attack_round_end = this.on_attack_round_end.bind(this);
        this.on_recover_round = this.on_recover_round.bind(this);
        this.is_battleground = is_battleground;
        this.board = (function() {
          var k, results;
          results = [];
          for (i = k = 1; k <= 8; i = ++k) {
            results.push((function() {
              var l, results1;
              results1 = [];
              for (j = l = 1; l <= 8; j = ++l) {
                results1.push(null);
              }
              return results1;
            })());
          }
          return results;
        })();
        if (this.is_battleground == null) {
          this.is_battleground = false;
        }
        if (this.is_battleground) {
          this.hook();
        }
      }

      set_out_board() {
        var b, w;
        w = 'white';
        b = 'black';
        this.place_piece(new piece.Piece(w, 'king'), king_spawn_coord[w]);
        this.place_piece(new piece.Piece(b, 'king'), king_spawn_coord[b]);
        this.spawn(w);
        this.spawn(w);
        this.spawn(b);
        return this.spawn(b);
      }

      * all_pieces() {
        var i, j, k, results;
        results = [];
        for (i = k = 1; k <= 8; i = ++k) {
          results.push((yield* (function*() {
            var l, results1;
            results1 = [];
            for (j = l = 1; l <= 8; j = ++l) {
              if (this.is_occupied([i, j])) {
                results1.push((yield [[i, j], this.get_piece([i, j])]));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this)));
        }
        return results;
      }

      clean_up_board() {
        var i, j, piece, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [[i, j], piece] = x;
          results.push(this.lift_piece([i, j]));
        }
        return results;
      }

      get_piece([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1];
      }

      lift_piece([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] = null;
      }

      place_piece(piece, [coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] = piece;
      }

      is_occupied([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] != null;
      }

      spawn(color) {
        return this.place_piece(new piece.Piece(color, 'pawn'), [calc.randint([1, 8]), spawn_row[color]]);
      }

      is_battleground() {
        return this.is_battleground;
      }

      clone() {
        var brd, coord, piece, ref, x;
        brd = new Board();
        ref = this.all_pieces();
        for (x of ref) {
          [coord, piece] = x;
          brd.place_piece(piece.clone(), coord);
        }
        return brd;
      }

      hook() {
        ev.hook('assist_round_begin', this.on_assist_round_begin);
        ev.hook('assist_round_end', this.on_assist_round_end);
        ev.hook('attack_round_begin', this.on_attack_round_begin);
        ev.hook('attack_round_end', this.on_attack_round_end);
        return ev.hook('recover_round', this.on_recover_round);
      }

      unhook() {
        ev.unhook('assist_round_begin', this.on_assist_round_begin);
        ev.unhook('assist_round_end', this.on_assist_round_end);
        ev.unhook('attack_round_begin', this.on_attack_round_begin);
        ev.unhook('attack_round_end', this.on_attack_round_end);
        return ev.unhook('recover_round', this.on_recover_round);
      }

      on_assist_round_begin() {
        var astee, coord, def_coord, moves, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          p.shield_total = p.shield_total_born;
          p.shield_heal = p.shield_heal_born;
          moves = rule.move.valid_moves(p.type, p.color, coord, this);
          results.push((function() {
            var k, len, ref1, results1;
            ref1 = moves.defensive;
            results1 = [];
            for (k = 0, len = ref1.length; k < len; k++) {
              def_coord = ref1[k];
              astee = this.get_piece(def_coord);
              results1.push(ev.trigger('battle_assist', {
                aster: p,
                astee: astee,
                coord_from: coord,
                coord_to: def_coord,
                assistance: p.assistance
              }));
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      on_assist_round_end() {
        var coord, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          results.push(p.adjust_shield());
        }
        return results;
      }

      on_attack_round_begin() {
        var atk_coord, coord, k, len, moves, p, ref, ref1, results, target, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          if (p.attack_cd_ticks > 0) {
            continue;
          }
          moves = rule.move.valid_moves(p.type, p.color, coord, this);
          if (moves.offensive.length === 0) {
            continue;
          }
          ref1 = moves.offensive;
          for (k = 0, len = ref1.length; k < len; k++) {
            atk_coord = ref1[k];
            target = this.get_piece(atk_coord);
            ev.trigger('battle_attack', {
              atker: p,
              atkee: target,
              coord_from: coord,
              coord_to: atk_coord,
              damage: p.attack
            });
          }
          results.push(p.activate_attack_cd());
        }
        return results;
      }

      on_attack_round_end() {
        var coord, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          if (p.is_dead()) {
            this.lift_piece(coord);
            results.push(ev.trigger('piece_die', {
              piece: p,
              coord: coord
            }));
          } else {
            results.push(p.reduce_attack_cd());
          }
        }
        return results;
      }

      on_recover_round() {
        var coord, p, ref, results, x;
        ref = this.all_pieces();
        results = [];
        for (x of ref) {
          [coord, p] = x;
          p.recover_shield();
          results.push(p.reduce_move_cd());
        }
        return results;
      }

      get_valid_moves(coord) {
        var p;
        if (!this.is_occupied(coord)) {
          return [];
        }
        p = this.get_piece(coord);
        if (!p.can_move()) {
          return [];
        }
        return rule.move.valid_moves(p.type, p.color, coord, this);
      }

      move_to(from_coord, to_coord) {
        var p;
        if (!this.is_occupied(from_coord)) {
          return;
        }
        p = this.get_piece(from_coord);
        this.place_piece(p, to_coord);
        this.lift_piece(from_coord);
        p.activate_move_cd();
        try_promoting(p, to_coord);
        return try_transforming(p, to_coord);
      }

    };

    spawn_row = {
      white: 7,
      black: 2
    };

    king_spawn_coord = {
      white: [5, 8],
      black: [5, 1]
    };

    return Board;

  }).call(this);

  try_promoting = function(piece, coord) {
    if (piece.type !== 'pawn') {
      return;
    }
    if ((piece.color === 'white' && coord[1] === 1) || (piece.color === 'black' && coord[1] === 8)) {
      piece.change_type('super_pawn');
      return piece.activate_move_cd();
    }
  };

  transform_column = ['rook', 'knight', 'bishop', 'queen', 'queen', 'bishop', 'knight', 'rook'];

  try_transforming = function(piece, coord) {
    if (piece.type !== 'super_pawn') {
      return;
    }
    if ((piece.color === 'white' && coord[1] === 8) || (piece.color === 'black' && coord[1] === 1)) {
      piece.change_type(transform_column[coord[0] - 1]);
      return piece.activate_move_cd();
    }
  };

  window.board = {Board};

}).call(this);

//# sourceMappingURL=board.js.map
