// Generated by CoffeeScript 2.2.1
(function() {
  var Board, get_state, init, on_render, set_state, write_buffer_to_buffer;

  Board = (function() {
    var king_spawn_coord, spawn_row;

    class Board {
      constructor(is_battleground) {
        var i, j;
        this.is_battleground = is_battleground;
        this.board = (function() {
          var k, results;
          results = [];
          for (i = k = 1; k <= 8; i = ++k) {
            results.push((function() {
              var l, results1;
              results1 = [];
              for (j = l = 1; l <= 8; j = ++l) {
                results1.push(null);
              }
              return results1;
            })());
          }
          return results;
        })();
        if (this.is_battle_board == null) {
          this.is_battle_board = false;
        }
      }

      set_out_board() {
        var b, w;
        w = 'white';
        b = 'black';
        this.place_piece(new piece.Piece(w, 'king', king_spawn_coord[w], this));
        this.place_piece(new piece.Piece(b, 'king', king_spawn_coord[b], this));
        this.spawn(w);
        this.spawn(w);
        this.spawn(w);
        this.spawn(b);
        this.spawn(b);
        return this.spawn(b);
      }

      clean_up_board() {
        var i, j, k, results;
        results = [];
        for (i = k = 1; k <= 8; i = ++k) {
          results.push((function() {
            var l, results1;
            results1 = [];
            for (j = l = 1; l <= 8; j = ++l) {
              if (this.is_occupied([i, j])) {
                this.get_piece([i, j]).unhook_actions();
                results1.push(this.lift_piece([i, j]));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      get_piece([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1];
      }

      lift_piece([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] = null;
      }

      place_piece(piece) {
        var coord_x, coord_y;
        [coord_x, coord_y] = piece.coordinate;
        return this.board[coord_x - 1][coord_y - 1] = piece;
      }

      is_occupied([coord_x, coord_y]) {
        return this.board[coord_x - 1][coord_y - 1] != null;
      }

      spawn(color) {
        return this.place_piece(new piece.Piece(color, 'pawn', [calc.randint([1, 8]), spawn_row[color]], this));
      }

      is_battleground() {
        return this.is_battleground;
      }

      clone() {
        var brd, i, j, k, l;
        brd = new Board();
        for (i = k = 1; k <= 8; i = ++k) {
          for (j = l = 1; l <= 8; j = ++l) {
            if (this.is_occupied([i, j])) {
              brd.place_piece((this.get_piece([i, j])).clone(brd));
            }
          }
        }
        return brd;
      }

    };

    spawn_row = {
      white: 7,
      black: 2
    };

    king_spawn_coord = {
      white: [5, 8],
      black: [5, 1]
    };

    return Board;

  }).call(this);

  init = function() {
    board.instance = new Board(true);
    board.instance.set_out_board();
    return ev.hook('render', on_render);
  };

  on_render = function(evt) {
    return paint.board(ui.ctx.static);
  };

  write_buffer_to_buffer = function(buffer_1, buffer_2, from_1, from_2, size) {
    var i, k, ref, results, view_1, view_2;
    view_1 = new Uint8Array(buffer_1);
    view_2 = new Uint8Array(buffer_2);
    results = [];
    for (i = k = 1, ref = size; undefined !== 0 && (1 <= ref ? 1 <= k && k <= ref : 1 >= k && k >= ref); i = 1 <= ref ? ++k : --k) {
      results.push(view_2[from_2++] = view_1[from_1++]);
    }
    return results;
  };

  get_state = function() {
    var buffer, k, l, len, len1, len2, m, p, pb, pieces, pointer, ref, serialized_pieces;
    serialized_pieces = [];
    ref = board.instance.board;
    for (k = 0, len = ref.length; k < len; k++) {
      pieces = ref[k];
      for (l = 0, len1 = pieces.length; l < len1; l++) {
        p = pieces[l];
        if (p != null) {
          serialized_pieces.push(piece.serialize_piece(p));
        }
      }
    }
    buffer = new ArrayBuffer(serialized_pieces.length * piece.serialization_btyes);
    pointer = 0;
    for (m = 0, len2 = serialized_pieces.length; m < len2; m++) {
      pb = serialized_pieces[m];
      write_buffer_to_buffer(pb, buffer, 0, pointer, piece.serialization_btyes);
      pointer += piece.serialization_btyes;
    }
    return buffer;
  };

  set_state = function(buffer) {
    var i, k, p, pb, piece_count, pointer, ref, results;
    board.instance.clean_up_board();
    piece_count = buffer.byteLength / piece.serialization_btyes;
    pointer = 0;
    results = [];
    for (i = k = 0, ref = piece_count; undefined !== 0 && (0 <= ref ? 0 <= k && k < ref : 0 >= k && k > ref); i = 0 <= ref ? ++k : --k) {
      pb = new ArrayBuffer(piece.serialization_btyes);
      write_buffer_to_buffer(buffer, pb, i * piece.serialization_btyes, 0, piece.serialization_btyes);
      p = piece.deserialize_piece(pb);
      results.push(board.instance.place_piece(p));
    }
    return results;
  };

  window.board = {
    init,
    instance: null,
    get_state,
    set_state
  };

}).call(this);
