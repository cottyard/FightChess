// Generated by CoffeeScript 1.8.0
(function() {
  var Board, Piece, chess_board, coord_to_pos, ctx_animate, ctx_background, ctx_static, cvs_animate, cvs_background, cvs_border_width, cvs_bounding_rect, cvs_size, cvs_static, draw_all_pieces, draw_background, draw_piece, get_coordinate, get_mouse_pos, grid_size, hoop, init_all_canvas, on_mousedown, on_mousemove, on_mouseup, picking_piece, piece_arrangement, piece_drawing_types, piece_font, pos_to_coord, set_canvas_attr, start, textarea;

  cvs_border_width = 3;

  cvs_size = 400;

  grid_size = cvs_size / 8;

  piece_font = "40px Courier New";

  cvs_animate = null;

  ctx_animate = null;

  cvs_static = null;

  ctx_static = null;

  cvs_background = null;

  ctx_background = null;

  cvs_bounding_rect = null;

  textarea = null;

  chess_board = null;

  Board = (function() {
    function Board() {
      var i, j;
      this.board = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; _i <= 8; i = ++_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (j = _j = 1; _j <= 8; j = ++_j) {
              _results1.push(null);
            }
            return _results1;
          })());
        }
        return _results;
      })();
    }

    Board.prototype.is_occupied = function(_arg) {
      var coord_x, coord_y;
      coord_x = _arg[0], coord_y = _arg[1];
      return this.board[coord_x - 1][coord_y - 1] != null;
    };

    Board.prototype.get_piece = function(_arg) {
      var coord_x, coord_y;
      coord_x = _arg[0], coord_y = _arg[1];
      return this.board[coord_x - 1][coord_y - 1];
    };

    Board.prototype.lift_piece = function(_arg) {
      var coord_x, coord_y;
      coord_x = _arg[0], coord_y = _arg[1];
      return this.board[coord_x - 1][coord_y - 1] = null;
    };

    Board.prototype.place_piece = function(piece) {
      var coord_x, coord_y, _ref;
      _ref = piece.coordinate, coord_x = _ref[0], coord_y = _ref[1];
      return this.board[coord_x - 1][coord_y - 1] = piece;
    };

    return Board;

  })();

  piece_arrangement = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

  Piece = (function() {
    function Piece(color, type, coordinate, board) {
      this.color = color;
      this.type = type;
      this.coordinate = coordinate;
      this.board = board;
    }

    Piece.prototype.move_to = function(new_coord) {
      if (this.is_onboard()) {
        this.board.lift_piece(this.coordinate);
      }
      this.coordinate = new_coord;
      if (new_coord != null) {
        return this.board.place_piece(this);
      }
    };

    Piece.prototype.is_onboard = function() {
      return this.coordinate != null;
    };

    return Piece;

  })();

  draw_background = function(ctx, size) {
    var x, y, _i, _j;
    ctx.save();
    util.set_style(ctx, util.style_brown);
    for (x = _i = 0; grid_size > 0 ? _i < size : _i > size; x = _i += grid_size) {
      for (y = _j = 0; grid_size > 0 ? _j < size : _j > size; y = _j += grid_size) {
        if ((x + y) / grid_size % 2 !== 0) {
          util.rectangle(ctx, x, y, grid_size, grid_size, true);
        }
      }
    }
    return ctx.restore();
  };

  set_canvas_attr = function(cvs, z_index, size) {
    cvs.style.border = "solid #000 " + cvs_border_width + "px";
    cvs.style.position = "absolute";
    cvs.style.cursor = "pointer";
    cvs.style['z-index'] = "" + z_index;
    return cvs.width = cvs.height = size;
  };

  init_all_canvas = function() {
    cvs_background = document.getElementById('background');
    ctx_background = cvs_background.getContext('2d');
    cvs_static = document.getElementById('static');
    ctx_static = cvs_static.getContext('2d');
    cvs_animate = document.getElementById('animate');
    ctx_animate = cvs_animate.getContext('2d');
    cvs_bounding_rect = cvs_animate.getBoundingClientRect();
    set_canvas_attr(cvs_background, 1, cvs_size);
    set_canvas_attr(cvs_static, 2, cvs_size);
    set_canvas_attr(cvs_animate, 3, cvs_size);
    ctx_static.font = piece_font;
    ctx_animate.font = piece_font;
    return draw_background(ctx_background, cvs_size);
  };

  hoop = function(num, _arg) {
    var range_lower, range_upper;
    range_lower = _arg[0], range_upper = _arg[1];
    if (num < range_lower) {
      num = range_lower;
    }
    if (num > range_upper) {
      num = range_upper;
    }
    return num;
  };

  coord_to_pos = function(_arg) {
    var pos_x, pos_y, x, y;
    x = _arg[0], y = _arg[1];
    pos_x = grid_size * (x - 0.5);
    pos_y = grid_size * (y - 0.5);
    return [pos_x, pos_y];
  };

  pos_to_coord = function(_arg) {
    var coord_x, coord_y, x, y;
    x = _arg[0], y = _arg[1];
    coord_x = hoop(Math.floor(x / grid_size) + 1, [1, 8]);
    coord_y = hoop(Math.floor(y / grid_size) + 1, [1, 8]);
    return [coord_x, coord_y];
  };

  piece_drawing_types = {
    black: {
      pawn: '\u265F',
      knight: '\u265E',
      bishop: '\u265D',
      rook: '\u265C',
      queen: '\u265B',
      king: '\u265A'
    },
    white: {
      pawn: '\u2659',
      knight: '\u2658',
      bishop: '\u2657',
      rook: '\u2656',
      queen: '\u2655',
      king: '\u2654'
    }
  };

  draw_piece = function(ctx, piece) {
    var color, pos_x, pos_y, type, _ref;
    _ref = coord_to_pos(piece.coordinate), pos_x = _ref[0], pos_y = _ref[1];
    color = piece.color;
    type = piece.type;
    return util.text(ctx, piece_drawing_types[color][type], pos_x - grid_size / 2 + 5, pos_y - grid_size / 2 + 40);
  };

  draw_all_pieces = function(ctx) {
    var i, j, _i, _results;
    util.clear_canvas(ctx_static);
    _results = [];
    for (i = _i = 1; _i <= 8; i = ++_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (j = _j = 1; _j <= 8; j = ++_j) {
          if (!chess_board.is_occupied([i, j])) {
            continue;
          }
          _results1.push(draw_piece(ctx, chess_board.get_piece([i, j])));
        }
        return _results1;
      })());
    }
    return _results;
  };

  get_mouse_pos = function(evt) {
    var mouse_x, mouse_y;
    mouse_x = evt.clientX - cvs_bounding_rect.left - cvs_border_width;
    mouse_y = evt.clientY - cvs_bounding_rect.top - cvs_border_width;
    return [mouse_x, mouse_y];
  };

  get_coordinate = function(evt) {
    return pos_to_coord(get_mouse_pos(evt));
  };

  picking_piece = null;

  on_mousedown = function(evt) {
    var coord;
    coord = get_coordinate(evt);
    return picking_piece = chess_board.get_piece(coord);
  };

  on_mouseup = function(evt) {
    var coord;
    if (!picking_piece) {
      return;
    }
    coord = get_coordinate(evt);
    picking_piece.move_to(coord);
    picking_piece = null;
    return draw_all_pieces(ctx_static);
  };

  on_mousemove = function(evt) {
    var coord;
    coord = pos_to_coord(get_mouse_pos(evt));
    return textarea.value = "" + coord;
  };

  start = function() {
    var x, _i, _j;
    init_all_canvas();
    chess_board = new Board();
    for (x = _i = 1; _i <= 8; x = ++_i) {
      chess_board.place_piece(new Piece('white', 'pawn', [x, 7], chess_board));
      chess_board.place_piece(new Piece('white', piece_arrangement[x - 1], [x, 8], chess_board));
    }
    for (x = _j = 1; _j <= 8; x = ++_j) {
      chess_board.place_piece(new Piece('black', 'pawn', [x, 2], chess_board));
      chess_board.place_piece(new Piece('black', piece_arrangement[x - 1], [x, 1], chess_board));
    }
    draw_all_pieces(ctx_static);
    textarea = document.getElementById('mousepos');
    cvs_animate.addEventListener("mousedown", on_mousedown, false);
    cvs_animate.addEventListener("mouseup", on_mouseup, false);
    return cvs_animate.addEventListener("mousemove", on_mousemove, false);
  };

  window.board = {
    start: start
  };

}).call(this);
