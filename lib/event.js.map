{
  "version": 3,
  "file": "event.js",
  "sourceRoot": "..",
  "sources": [
    "src\\event.coffee"
  ],
  "names": [],
  "mappings": ";AAAA;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,cAAA,EAAA,6BAAA,EAAA,cAAA,EAAA,WAAA,EAAA,WAAA,EAAA,IAAA,EAAA,MAAA,EAAA,QAAA,EAAA,IAAA,EAAA,IAAA,EAAA,MAAA,EAAA,OAAA,EAAA,WAAA,EAAA;;EAsCA,QAAA,GAAW,CAAA;;EACX,WAAA,GAAc;;EACd,WAAA,GAAc;;EACd,MAAA,GAAS;;EAET,OAAA,GAAU,QAAA,CAAC,QAAD,EAAW,GAAX,CAAA;IACR,WAAW,CAAC,IAAZ,CAAiB,CAAC,QAAD,EAAW,GAAX,CAAjB;IACA,IAAG,CAAI,WAAP;MACE,WAAA,GAAc;MACd,cAAA,CAAA;aACA,WAAA,GAAc,MAHhB;;EAFQ;;EAOV,WAAA,GAAc,QAAA,CAAC,QAAD,EAAW,GAAX,CAAA;IACZ,WAAW,CAAC,IAAZ,CAAiB,CAAC,QAAD,EAAW,GAAX,CAAjB;WACA,cAAA,CAAA;EAFY;;EAId,cAAA,GAAiB,QAAA,CAAA,CAAA;AACf,QAAA;IAAA,IAAA,CAAO,MAAP;AACE;aAAM,WAAW,CAAC,MAAZ,GAAqB,CAA3B;qBACE,6BAAA,CAAA;MADF,CAAA;qBADF;;EADe;;EAKjB,6BAAA,GAAgC,QAAA,CAAA,CAAA;AAC9B,QAAA,GAAA,EAAA;IAAA,CAAC,QAAD,EAAW,GAAX,CAAA,GAAkB,WAAW,CAAC,KAAZ,CAAA;WAClB,cAAA,CAAe,QAAf,EAAyB,GAAzB;EAF8B;;EAIhC,cAAA,GAAiB,QAAA,CAAC,QAAD,EAAW,GAAX,CAAA;AACf,QAAA,GAAA,EAAA,IAAA,EAAA,CAAA,EAAA,GAAA,EAAA,GAAA,EAAA;IAAA,IAAA,GAAO,QAAS,CAAA,QAAA;IAChB,IAAG,YAAH;AAGE;;;AAAA;MAAA,KAAA,qCAAA;;qBACE,GAAA,CAAI,GAAJ;MADF,CAAA;qBAHF;;EAFe;;EAQjB,IAAA,GAAO,QAAA,CAAC,QAAD,EAAW,GAAX,CAAA;IACL,IAAO,0BAAP;MACE,QAAS,CAAA,QAAA,CAAT,GAAqB,GADvB;;WAEA,QAAS,CAAA,QAAA,CAAS,CAAC,IAAnB,CAAwB,GAAxB;EAHK;;EAKP,MAAA,GAAS,QAAA,CAAC,QAAD,EAAW,GAAX,CAAA;AACP,QAAA;IAAA,IAAA,GAAO,QAAS,CAAA,QAAA;IAChB,IAAG,YAAH;aACE,IAAI,CAAC,sBAAL,CAA4B,GAA5B,EAAiC,IAAjC,EADF;;EAFO;;EAKT,IAAA,GAAO,QAAA,CAAA,CAAA;IACL,QAAA,GAAW,CAAA;IACX,WAAA,GAAc;WACd,WAAA,GAAc;EAHT;;EAKP,IAAA,GAAO,QAAA,CAAA,CAAA;WACL,MAAA,GAAS;EADJ;;EAGP,MAAA,GAAS,QAAA,CAAA,CAAA;WACP,MAAA,GAAS;EADF;;EAGT,MAAM,CAAC,EAAP,GAAY,CACV,IADU,EAEV,OAFU,EAGV,WAHU,EAIV,IAJU,EAKV,MALU,EAMV,IANU,EAOV,MAPU;AA5FZ",
  "sourcesContent": [
    "###\r\ndata structure spec\r\n  pos: [pos_x, pos_y]\r\n  coord: [coord_x, coord_y]\r\n\r\nall events:\r\n\r\nraw input\r\n  mousedown, mouseup, mousemove {pos}\r\ninput operation\r\n  pick, drop, hover {coord}\r\ngame operation\r\n  op_movepiece {piece, coord_from, coord_to}\r\nbattle\r\n  battle_attack {piece_atker, piece_atkee, coord_from, coord_to, damage}\r\n  battle_assist {piece_aster, piece_astee, coord_from, coord_to, assistance}\r\n  battle_heal {piece_healer, piece_healee, coord_from, coord_to, recuperation}\r\n  battle_move {piece, coord_from, coord_to}\r\ngame\r\n  move_round_begin { board }, move_round { board }, move_round_end { board }\r\n  assist_round_begin { board }, assist_round { board }, assist_round_end { board }\r\n  recover_round_begin { board }, recover_round { board }, recover_round_end { board }\r\n  attack_round_begin { board }, attack_round { board }, attack_round_end { board }\r\n  end_of_rounds { board }\r\n  ai_think_round { board }\r\n  gametick {}\r\n  render {}\r\n  game_end { result: draw/win, player }\r\npiece state\r\n  piece_die {piece, coord}\r\n  piece_hurt {piece, coord}\r\nnetwork\r\n  network_out_gamestate {gamestate}\r\n  network_out_operation {operation}\r\n  network_in_gamestate {gamestate}\r\n  network_in_operation {operation}\r\n###\r\n\r\nhandlers = {}\r\ndispatching = no\r\nevent_queue = []\r\nhalted = no\r\n\r\ntrigger = (evt_name, evt) ->\r\n  event_queue.push [evt_name, evt]\r\n  if not dispatching # the event being dispatched may trigger other events\r\n    dispatching = yes\r\n    dispatch_queue()\r\n    dispatching = no\r\n\r\ntrigger_now = (evt_name, evt) ->\r\n  event_queue.push [evt_name, evt]\r\n  dispatch_queue()\r\n\r\ndispatch_queue = ->\r\n  unless halted\r\n    while event_queue.length > 0\r\n      dispatch_one_event_from_queue()\r\n\r\ndispatch_one_event_from_queue = ->\r\n  [evt_name, evt] = event_queue.shift()\r\n  dispatch_event evt_name, evt\r\n\r\ndispatch_event = (evt_name, evt) ->\r\n  hdls = handlers[evt_name]\r\n  if hdls?\r\n    # some handlers may be unhooked during the invocation,\r\n    # so make a copy of all handlers first before invoking them.\r\n    for hdl in calc.copy_array hdls \r\n      hdl evt\r\n\r\nhook = (evt_name, hdl) ->\r\n  unless handlers[evt_name]?\r\n    handlers[evt_name] = []\r\n  handlers[evt_name].push hdl\r\n\r\nunhook = (evt_name, hdl) ->\r\n  hdls = handlers[evt_name]\r\n  if hdls?\r\n    calc.remove_item_from_array hdl, hdls\r\n\r\ninit = ->\r\n  handlers = {}\r\n  dispatching = no \r\n  event_queue = []\r\n\r\nhalt = ->\r\n  halted = yes\r\n\r\nresume = ->\r\n  halted = no\r\n\r\nwindow.ev = {\r\n  init,\r\n  trigger,\r\n  trigger_now,\r\n  hook,\r\n  unhook,\r\n  halt,\r\n  resume\r\n}"
  ]
}