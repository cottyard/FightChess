// Generated by CoffeeScript 1.8.0
(function() {
  var Piece, add_offensive_move, add_regular_move, bishop_moves, bishop_moves_orients, is_in_board, is_in_range, king_moves, king_moves_deltas, knight_moves, knight_moves_deltas, move_strategies, pawn_moves, queen_moves, rook_moves, rook_moves_orients;

  is_in_range = function(num, _arg) {
    var lower, upper;
    lower = _arg[0], upper = _arg[1];
    return num >= lower && num <= upper;
  };

  is_in_board = function(coord) {
    var x, y;
    x = coord[0], y = coord[1];
    return is_in_range(x, [1, 8]) && is_in_range(y, [1, 8]);
  };

  add_regular_move = function(moves, coord, board) {
    if (is_in_board(coord) && !board.is_occupied(coord)) {
      moves.push(coord);
      return true;
    }
    return false;
  };

  add_offensive_move = function(moves, color, coord, board) {
    if (is_in_board(coord) && board.is_occupied(coord) && board.get_piece(coord).color !== color) {
      moves.push(coord);
      return true;
    }
    return false;
  };

  pawn_moves = function(color, coord, board) {
    var col, offensive, orient, regular, row, starting_row;
    regular = [];
    offensive = [];
    col = coord[0], row = coord[1];
    starting_row = color === 'black' ? 2 : 7;
    orient = color === 'black' ? 1 : -1;
    if (add_regular_move(regular, [col, row + orient], board)) {
      if (row === starting_row) {
        add_regular_move(regular, [col, row + 2 * orient], board);
      }
    }
    add_offensive_move(offensive, color, [col + 1, row + orient], board);
    add_offensive_move(offensive, color, [col - 1, row + orient], board);
    return {
      regular: regular,
      offensive: offensive
    };
  };

  knight_moves_deltas = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];

  knight_moves = function(color, coord, board) {
    var col, dx, dy, offensive, regular, row, _i, _len, _ref;
    regular = [];
    offensive = [];
    col = coord[0], row = coord[1];
    for (_i = 0, _len = knight_moves_deltas.length; _i < _len; _i++) {
      _ref = knight_moves_deltas[_i], dx = _ref[0], dy = _ref[1];
      add_regular_move(regular, [col + dx, row + dy], board);
      add_offensive_move(offensive, color, [col + dx, row + dy], board);
    }
    return {
      regular: regular,
      offensive: offensive
    };
  };

  bishop_moves_orients = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

  bishop_moves = function(color, coord, board) {
    var col, dx, dy, next, offensive, regular, row, _i, _len, _ref;
    regular = [];
    offensive = [];
    col = coord[0], row = coord[1];
    for (_i = 0, _len = bishop_moves_orients.length; _i < _len; _i++) {
      _ref = bishop_moves_orients[_i], dx = _ref[0], dy = _ref[1];
      next = [col, row];
      while (true) {
        next = [next[0] + dx, next[1] + dy];
        if (!add_regular_move(regular, next, board)) {
          break;
        }
      }
      add_offensive_move(offensive, color, next, board);
    }
    return {
      regular: regular,
      offensive: offensive
    };
  };

  rook_moves_orients = [[1, 0], [0, 1], [-1, 0], [0, -1]];

  rook_moves = function(color, coord, board) {
    var col, dx, dy, next, offensive, regular, row, _i, _len, _ref;
    regular = [];
    offensive = [];
    col = coord[0], row = coord[1];
    for (_i = 0, _len = rook_moves_orients.length; _i < _len; _i++) {
      _ref = rook_moves_orients[_i], dx = _ref[0], dy = _ref[1];
      next = [col, row];
      while (true) {
        next = [next[0] + dx, next[1] + dy];
        if (!add_regular_move(regular, next, board)) {
          break;
        }
      }
      add_offensive_move(offensive, color, next, board);
    }
    return {
      regular: regular,
      offensive: offensive
    };
  };

  queen_moves = function(color, coord, board) {
    var col, dx, dy, next, offensive, regular, row, _i, _len, _ref, _ref1;
    regular = [];
    offensive = [];
    col = coord[0], row = coord[1];
    _ref = rook_moves_orients.concat(bishop_moves_orients);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], dx = _ref1[0], dy = _ref1[1];
      next = [col, row];
      while (true) {
        next = [next[0] + dx, next[1] + dy];
        if (!add_regular_move(regular, next, board)) {
          break;
        }
      }
      add_offensive_move(offensive, color, next, board);
    }
    return {
      regular: regular,
      offensive: offensive
    };
  };

  king_moves_deltas = [[1, 0], [0, 1], [-1, 0], [0, -1], [1, 1], [1, -1], [-1, 1], [-1, -1]];

  king_moves = function(color, coord, board) {
    var col, dx, dy, offensive, regular, row, _i, _len, _ref;
    regular = [];
    offensive = [];
    col = coord[0], row = coord[1];
    for (_i = 0, _len = king_moves_deltas.length; _i < _len; _i++) {
      _ref = king_moves_deltas[_i], dx = _ref[0], dy = _ref[1];
      add_regular_move(regular, [col + dx, row + dy], board);
      add_offensive_move(offensive, color, [col + dx, row + dy], board);
    }
    return {
      regular: regular,
      offensive: offensive
    };
  };

  move_strategies = {
    pawn: pawn_moves,
    knight: knight_moves,
    bishop: bishop_moves,
    rook: rook_moves,
    queen: queen_moves,
    king: king_moves
  };

  Piece = (function() {
    function Piece(color, type, coordinate, board) {
      this.color = color;
      this.type = type;
      this.coordinate = coordinate;
      this.board = board;
      this.strategy;
    }

    Piece.prototype.move_to = function(new_coord) {
      if (this.is_onboard()) {
        this.board.lift_piece(this.coordinate);
      }
      this.coordinate = new_coord;
      if (new_coord != null) {
        return this.board.place_piece(this);
      }
    };

    Piece.prototype.valid_moves = function() {
      return move_strategies[this.type](this.color, this.coordinate, this.board);
    };

    Piece.prototype.is_onboard = function() {
      return this.coordinate != null;
    };

    return Piece;

  })();

  window.piece = {
    Piece: Piece
  };

}).call(this);
